import { createKey, getParamKeys, extractPathFromNavigationTarget, getPathFromTo, isModalShown, isPopoutShown, } from '../utils/utils';
import { NAVIGATION_BLOCKER_KEY, STATE_KEY_BLOCK_FORWARD_NAVIGATION, STATE_KEY_SHOW_MODAL, STATE_KEY_SHOW_POPOUT, } from '../const';
import { buildPanelPathFromModalMatch } from '../utils/buildPanelPathFromModalMatch';
import { TransactionExecutor } from './TransactionExecutor';
import { NavigationTransaction } from '../entities/NavigationTransaction';
export class DefaultRouteNavigator {
    constructor(router, viewHistory, setPopout) {
        this.viewHistory = viewHistory;
        this.blockers = new Map();
        this.blockerId = 0;
        this.router = router;
        this.setPopout = setPopout;
    }
    async push(to, paramsOrOptions = {}, options = {}) {
        const { preparedOptions, preparedParams } = this.parseParams(to, paramsOrOptions, options);
        const fullOptions = {
            ...preparedOptions,
            replace: Boolean(this.router.state.location.state?.[STATE_KEY_BLOCK_FORWARD_NAVIGATION]),
        };
        await this.navigate(to, fullOptions, preparedParams);
    }
    async replace(to, paramsOrOptions = {}, options = {}) {
        const { preparedOptions, preparedParams } = this.parseParams(to, paramsOrOptions, options);
        await this.navigate(to, { ...preparedOptions, replace: true }, preparedParams);
    }
    async back(to = 1) {
        if (to === 0) {
            return;
        }
        await this.go(-Math.abs(to));
    }
    async backToFirst() {
        if (this.viewHistory.position > 0) {
            await this.go(-this.viewHistory.position);
        }
        else {
            await TransactionExecutor.doNext();
        }
    }
    async go(to) {
        if (to === 0) {
            await TransactionExecutor.doNext();
        }
        else {
            await this.router.navigate(to);
        }
    }
    runSync(actions) {
        const transaction = new NavigationTransaction(actions);
        TransactionExecutor.add(transaction);
        TransactionExecutor.doNext();
        return transaction.donePromise;
    }
    async showModal(id) {
        await this.router.navigate(this.router.state.location, {
            state: { [STATE_KEY_SHOW_MODAL]: id, [STATE_KEY_BLOCK_FORWARD_NAVIGATION]: true },
            replace: isModalShown(this.router.state.location),
        });
    }
    async hideModal(pushPanel = false) {
        if ((!pushPanel && !this.viewHistory.isFirstPage) || isModalShown(this.router.state.location)) {
            await this.router.navigate(-1);
        }
        else {
            const modalMatch = this.router.state.matches.find((match) => 'modal' in match.route);
            if (modalMatch) {
                const route = modalMatch.route;
                const path = buildPanelPathFromModalMatch(modalMatch, this.router);
                if (!path) {
                    const rootMessage = route.root ? `root: ${route.root} ` : '';
                    throw new Error(`There is no route registered for panel with ${rootMessage}, view: ${route.view}, panel: ${route.panel}.
Make sure this route exists or use hideModal with pushPanel set to false.`);
                }
                await this.navigate(path, { keepSearchParams: true });
            }
            else {
                await TransactionExecutor.doNext();
            }
        }
    }
    async showPopout(popout) {
        this.setPopout(popout);
        const state = {
            [STATE_KEY_SHOW_POPOUT]: createKey(),
            [STATE_KEY_BLOCK_FORWARD_NAVIGATION]: true,
        };
        if (isModalShown(this.router.state.location)) {
            state[STATE_KEY_SHOW_MODAL] = this.router.state.location.state[STATE_KEY_SHOW_MODAL];
        }
        const replace = isModalShown(this.router.state.location) || isPopoutShown(this.router.state.location);
        await this.router.navigate(this.router.state.location, { state, replace });
    }
    async hidePopout() {
        if (isPopoutShown(this.router.state.location)) {
            this.setPopout(null);
            if (isModalShown(this.router.state.location)) {
                await this.router.navigate(this.router.state.location, {
                    state: {
                        [STATE_KEY_BLOCK_FORWARD_NAVIGATION]: true,
                        [STATE_KEY_SHOW_MODAL]: this.router.state.location.state[STATE_KEY_SHOW_MODAL],
                    },
                    replace: true,
                });
            }
            else {
                await this.router.navigate(-1);
            }
        }
        else {
            await TransactionExecutor.doNext();
        }
    }
    block(blocker) {
        const key = (++this.blockerId).toString();
        this.blockers.set(key, blocker);
        const onLeave = (data) => {
            return Array.from(this.blockers.values()).some((fn) => fn(data));
        };
        this.router.getBlocker(NAVIGATION_BLOCKER_KEY, onLeave);
        return () => {
            this.blockers.delete(key);
        };
    }
    async navigate(to, opts, params = {}) {
        let path = getPathFromTo({ to, params, defaultPathname: this.router.state.location.pathname });
        const newUrl = new URL(path, window.location.origin);
        if (opts?.keepSearchParams) {
            const currentSearchParams = new URLSearchParams(this.router.state.location.search);
            const newSearchParams = new URLSearchParams(newUrl.search);
            currentSearchParams.forEach((value, key) => {
                if (!newSearchParams.has(key)) {
                    newSearchParams.set(key, value);
                }
            });
            newUrl.search = newSearchParams.toString();
            path = newUrl.pathname + (newUrl.search ? `${newUrl.search}` : '');
        }
        await this.router.navigate(path, opts);
    }
    validateOptions({ state, keepSearchParams } = {}) {
        const invalidState = state && typeof state !== 'object';
        const invalidKeepSearchParams = keepSearchParams && typeof keepSearchParams !== 'boolean';
        if (invalidState || invalidKeepSearchParams) {
            console.warn('Invalid navigate options type');
            return {};
        }
        return { state, keepSearchParams };
    }
    parseParams(to, paramsOrOptions = {}, options = {}) {
        const path = extractPathFromNavigationTarget(to);
        if (getParamKeys(path).length) {
            return {
                preparedParams: paramsOrOptions,
                preparedOptions: this.validateOptions(options),
            };
        }
        return { preparedParams: {}, preparedOptions: this.validateOptions(paramsOrOptions) };
    }
}
//# sourceMappingURL=DefaultRouteNavigator.js.map