{"version":3,"sources":["../../src/lib/date.ts"],"sourcesContent":["import { lightFormat } from 'date-fns';\n\nexport function parse(input: string, format: string, referenceDate: Date = new Date()): Date {\n  const match2 = /^\\d\\d/; // 00 - 99\n  const match4 = /^\\d{4}/; // 0000 - 9999\n\n  const entries: Array<[string, RegExp, (val: string) => [string, number, boolean]]> = [\n    ['yyyy', match4, (val) => ['Y', +val, true]],\n    [\n      'MM',\n      match2,\n      (val) => {\n        const numVal = +val;\n        const okay = numVal > 0 && numVal <= 12;\n\n        return ['M', numVal - 1, okay];\n      },\n    ],\n    ['dd', match2, (val) => ['D', +val, true]],\n    [\n      'HH',\n      match2,\n      (val) => {\n        const numVal = parseInt(val, 10);\n        const okay = numVal >= 0 && numVal < 24;\n\n        return ['h', numVal, okay];\n      },\n    ],\n    [\n      'mm',\n      match2,\n      (val) => {\n        const numVal = parseInt(val, 10);\n        const okay = numVal >= 0 && numVal < 60;\n\n        return ['m', numVal, okay];\n      },\n    ],\n  ];\n\n  const superRegExp = new RegExp(entries.map((item) => item[0]).join('|'), 'g');\n\n  const store: {\n    [key: string]: number;\n  } = {\n    y: referenceDate.getFullYear(),\n    M: referenceDate.getMonth(),\n    d: referenceDate.getDate(),\n    h: referenceDate.getHours(),\n    m: referenceDate.getMinutes(),\n    s: referenceDate.getSeconds(),\n    ms: referenceDate.getMilliseconds(),\n  };\n\n  let prevInputIndex = 0;\n  let lastNonFormatting = '';\n  let lastFormatIndex = 0;\n  let found = false;\n\n  while (true) {\n    const match = superRegExp.exec(format);\n\n    if (!match) {\n      break;\n    }\n\n    const length = match[0].length;\n    const atIndex = superRegExp.lastIndex - length;\n\n    const item = entries.find((item) => item[0] === match[0])!;\n\n    lastNonFormatting = format.slice(lastFormatIndex, atIndex);\n    lastFormatIndex = superRegExp.lastIndex;\n\n    if (\n      input.slice(prevInputIndex, prevInputIndex + lastNonFormatting.length) !== lastNonFormatting\n    ) {\n      return new Date('');\n    }\n\n    const value = input.slice(prevInputIndex + lastNonFormatting.length).match(item[1]);\n\n    if (!value) {\n      return new Date('');\n    }\n\n    prevInputIndex = prevInputIndex + lastNonFormatting.length + value[0].length;\n\n    const [key, newValue, okay] = item[2](value[0]);\n\n    if (!okay) {\n      return new Date('');\n    }\n\n    store[key] = newValue;\n    found = true;\n  }\n\n  if (!found) {\n    return new Date('');\n  }\n\n  const date = new Date(store.Y, store.M, store.D, store.h, store.m, store.s, store.ms);\n\n  // Since days of months are dynamic, they can't be validated in entries,\n  // so we check it here, in the finalized date\n  if (date.getMonth() !== store.M || date.getDate() !== store.D) {\n    return new Date('');\n  }\n\n  return date;\n}\n\nexport function format(date: Date | number, format: string): string {\n  return lightFormat(date, format);\n}\n\nexport function isMatch(input: string, format: string): boolean {\n  return !isNaN(+parse(input, format));\n}\n"],"names":["lightFormat","parse","input","format","referenceDate","Date","match2","match4","entries","val","numVal","okay","parseInt","superRegExp","RegExp","map","item","join","store","y","getFullYear","M","getMonth","d","getDate","h","getHours","m","getMinutes","s","getSeconds","ms","getMilliseconds","prevInputIndex","lastNonFormatting","lastFormatIndex","found","match","exec","length","atIndex","lastIndex","find","slice","value","key","newValue","date","Y","D","isMatch","isNaN"],"mappings":"AAAA,SAASA,WAAW,QAAQ,WAAW;AAEvC,OAAO,SAASC,MAAMC,KAAa,EAAEC,MAAc,EAAEC,gBAAsB,IAAIC,MAAM;IACnF,MAAMC,SAAS,SAAS,UAAU;IAClC,MAAMC,SAAS,UAAU,cAAc;IAEvC,MAAMC,UAA+E;QACnF;YAAC;YAAQD;YAAQ,CAACE,MAAQ;oBAAC;oBAAK,CAACA;oBAAK;iBAAK;SAAC;QAC5C;YACE;YACAH;YACA,CAACG;gBACC,MAAMC,SAAS,CAACD;gBAChB,MAAME,OAAOD,SAAS,KAAKA,UAAU;gBAErC,OAAO;oBAAC;oBAAKA,SAAS;oBAAGC;iBAAK;YAChC;SACD;QACD;YAAC;YAAML;YAAQ,CAACG,MAAQ;oBAAC;oBAAK,CAACA;oBAAK;iBAAK;SAAC;QAC1C;YACE;YACAH;YACA,CAACG;gBACC,MAAMC,SAASE,SAASH,KAAK;gBAC7B,MAAME,OAAOD,UAAU,KAAKA,SAAS;gBAErC,OAAO;oBAAC;oBAAKA;oBAAQC;iBAAK;YAC5B;SACD;QACD;YACE;YACAL;YACA,CAACG;gBACC,MAAMC,SAASE,SAASH,KAAK;gBAC7B,MAAME,OAAOD,UAAU,KAAKA,SAAS;gBAErC,OAAO;oBAAC;oBAAKA;oBAAQC;iBAAK;YAC5B;SACD;KACF;IAED,MAAME,cAAc,IAAIC,OAAON,QAAQO,GAAG,CAAC,CAACC,OAASA,IAAI,CAAC,EAAE,EAAEC,IAAI,CAAC,MAAM;IAEzE,MAAMC,QAEF;QACFC,GAAGf,cAAcgB,WAAW;QAC5BC,GAAGjB,cAAckB,QAAQ;QACzBC,GAAGnB,cAAcoB,OAAO;QACxBC,GAAGrB,cAAcsB,QAAQ;QACzBC,GAAGvB,cAAcwB,UAAU;QAC3BC,GAAGzB,cAAc0B,UAAU;QAC3BC,IAAI3B,cAAc4B,eAAe;IACnC;IAEA,IAAIC,iBAAiB;IACrB,IAAIC,oBAAoB;IACxB,IAAIC,kBAAkB;IACtB,IAAIC,QAAQ;IAEZ,MAAO,KAAM;QACX,MAAMC,QAAQxB,YAAYyB,IAAI,CAACnC;QAE/B,IAAI,CAACkC,OAAO;YACV;QACF;QAEA,MAAME,SAASF,KAAK,CAAC,EAAE,CAACE,MAAM;QAC9B,MAAMC,UAAU3B,YAAY4B,SAAS,GAAGF;QAExC,MAAMvB,OAAOR,QAAQkC,IAAI,CAAC,CAAC1B,OAASA,IAAI,CAAC,EAAE,KAAKqB,KAAK,CAAC,EAAE;QAExDH,oBAAoB/B,OAAOwC,KAAK,CAACR,iBAAiBK;QAClDL,kBAAkBtB,YAAY4B,SAAS;QAEvC,IACEvC,MAAMyC,KAAK,CAACV,gBAAgBA,iBAAiBC,kBAAkBK,MAAM,MAAML,mBAC3E;YACA,OAAO,IAAI7B,KAAK;QAClB;QAEA,MAAMuC,QAAQ1C,MAAMyC,KAAK,CAACV,iBAAiBC,kBAAkBK,MAAM,EAAEF,KAAK,CAACrB,IAAI,CAAC,EAAE;QAElF,IAAI,CAAC4B,OAAO;YACV,OAAO,IAAIvC,KAAK;QAClB;QAEA4B,iBAAiBA,iBAAiBC,kBAAkBK,MAAM,GAAGK,KAAK,CAAC,EAAE,CAACL,MAAM;QAE5E,MAAM,CAACM,KAAKC,UAAUnC,KAAK,GAAGK,IAAI,CAAC,EAAE,CAAC4B,KAAK,CAAC,EAAE;QAE9C,IAAI,CAACjC,MAAM;YACT,OAAO,IAAIN,KAAK;QAClB;QAEAa,KAAK,CAAC2B,IAAI,GAAGC;QACbV,QAAQ;IACV;IAEA,IAAI,CAACA,OAAO;QACV,OAAO,IAAI/B,KAAK;IAClB;IAEA,MAAM0C,OAAO,IAAI1C,KAAKa,MAAM8B,CAAC,EAAE9B,MAAMG,CAAC,EAAEH,MAAM+B,CAAC,EAAE/B,MAAMO,CAAC,EAAEP,MAAMS,CAAC,EAAET,MAAMW,CAAC,EAAEX,MAAMa,EAAE;IAEpF,wEAAwE;IACxE,6CAA6C;IAC7C,IAAIgB,KAAKzB,QAAQ,OAAOJ,MAAMG,CAAC,IAAI0B,KAAKvB,OAAO,OAAON,MAAM+B,CAAC,EAAE;QAC7D,OAAO,IAAI5C,KAAK;IAClB;IAEA,OAAO0C;AACT;AAEA,OAAO,SAAS5C,OAAO4C,IAAmB,EAAE5C,MAAc;IACxD,OAAOH,YAAY+C,MAAM5C;AAC3B;AAEA,OAAO,SAAS+C,QAAQhD,KAAa,EAAEC,MAAc;IACnD,OAAO,CAACgD,MAAM,CAAClD,MAAMC,OAAOC;AAC9B"}