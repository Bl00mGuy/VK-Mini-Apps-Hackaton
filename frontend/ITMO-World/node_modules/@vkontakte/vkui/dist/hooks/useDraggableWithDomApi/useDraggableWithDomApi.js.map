{"version":3,"sources":["../../../src/hooks/useDraggableWithDomApi/useDraggableWithDomApi.ts"],"sourcesContent":["import * as React from 'react';\nimport type { CustomTouchEvent } from '../../components/Touch/Touch';\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { createAutoScrollController, getAutoScrollingData } from './autoScroll';\nimport {\n  AUTO_SCROLL_START_DELAY,\n  DATA_DRAGGABLE_PLACEHOLDER_KEY,\n  ITEM_INITIAL_INDEX,\n} from './constants';\nimport type {\n  Direction,\n  DraggingItem,\n  PlaceholderItem,\n  SiblingItem,\n  UseDraggable,\n  UseDraggableProps,\n} from './types';\nimport {\n  getTargetIsOverOrUnderElData,\n  setDraggingItemShiftStyles,\n  setInitialDraggingItemStyles,\n  setInitialPlaceholderItemStyles,\n  setInitialSiblingItemStyles,\n  setSiblingItemsShiftStyles,\n  unsetInitialDraggingItemStyles,\n  unsetInitialPlaceholderItemStyles,\n  unsetInitialSiblingItemStyles,\n} from './utils';\n\nexport const useDraggableWithDomApi = <T extends HTMLElement>({\n  elRef: draggingElRef,\n  onDragFinish,\n}: UseDraggableProps<T>): UseDraggable => {\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n\n  const scrollElRef = React.useRef<Element | Window | null>(null);\n  const lastScrollTopRef = React.useRef<number>(0);\n  const scrollControllerRef = React.useRef<ReturnType<typeof createAutoScrollController> | null>(\n    null,\n  );\n  const initializeScrollRefs = (draggableEl: HTMLElement) => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    lastScrollTopRef.current = 0;\n    scrollControllerRef.current?.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n\n  const lastDragDirectionRef = React.useRef<Direction | undefined>(undefined);\n  const toggleDragDirection = (prevShiftY: number, nextShiftY: number) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n\n  const itemStartIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef<DraggingItem | null>(null);\n  const placeholderItemRef = React.useRef<PlaceholderItem | null>(null);\n  const siblingItemsRef = React.useRef<SiblingItem[]>([]);\n  const itemsGapRef = React.useRef<number>(0);\n  const initializeItems = (draggingEl: HTMLElement) => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const parentElement = draggingEl.parentElement;\n    itemsGapRef.current = parentElement ? parseInt(parentElement.style.gridGap) : 0;\n\n    const { children } = parentElement || { children: [] };\n    Array.prototype.forEach.call(children, (el: HTMLElement, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = { index, el, draggingElRect };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = { index, el, draggingElRect };\n      } else {\n        siblingItemsRef.current.push({ index, el, shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index, draggingElRect }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach((sibling) =>\n      setInitialSiblingItemStyles(sibling, itemsGapRef.current),\n    ); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n\n    const swappedItemIndexRange = { from: itemStartIndexRef.current, to: itemEndIndexRef.current };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = (\n    clientY: number,\n  ): [Array<[SiblingItem, Direction]>, Array<[SiblingItem, Direction]>] => {\n    const shiftItemEls: Array<[SiblingItem, Direction]> = [];\n    const unshiftItemEls: Array<[SiblingItem, Direction]> = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach((siblingItem) => {\n      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(\n        clientY,\n        getBoundingClientRect(siblingItem.el),\n      );\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (\n    shiftItemEls: Array<[SiblingItem, Direction]>,\n    unshiftItemEls: Array<[SiblingItem, Direction]>,\n  ) => {\n    shiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n    unshiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n  };\n\n  const schedulingAutoScrollTimeoutIdRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current\n          ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current)\n          : {\n              shouldScrolling: false,\n              y: 0,\n            };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n\n  const onDragStart = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const onDragMove = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    const draggingEl = draggingElRef.current;\n\n    if (!draggingEl) {\n      return;\n    }\n\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(\n          lastClientYRef.current,\n        );\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging((prevDragging) => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n\n  const onDragEnd = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n\n    const [shiftItemEls, unshiftItemEls] =\n      getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n\n  useIsomorphicLayoutEffect(\n    function recalculateOnScroll() {\n      const scrollEl = scrollElRef.current;\n      if (!dragging || !scrollEl) {\n        return;\n      }\n      scrollEl.addEventListener('scroll', handleScroll);\n      return () => {\n        if (scrollEl) {\n          scrollEl.removeEventListener('scroll', handleScroll);\n        }\n      };\n    },\n    [dragging, handleScroll],\n  );\n\n  useIsomorphicLayoutEffect(\n    () =>\n      function componentWillUnmount() {\n        if (placeholderItemRef.current) {\n          unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n        }\n      },\n    [],\n  );\n\n  return { dragging, onDragStart, onDragMove, onDragEnd };\n};\n"],"names":["React","getBoundingClientRect","getNearestOverflowAncestor","getNodeScroll","useIsomorphicLayoutEffect","createAutoScrollController","getAutoScrollingData","AUTO_SCROLL_START_DELAY","DATA_DRAGGABLE_PLACEHOLDER_KEY","ITEM_INITIAL_INDEX","getTargetIsOverOrUnderElData","setDraggingItemShiftStyles","setInitialDraggingItemStyles","setInitialPlaceholderItemStyles","setInitialSiblingItemStyles","setSiblingItemsShiftStyles","unsetInitialDraggingItemStyles","unsetInitialPlaceholderItemStyles","unsetInitialSiblingItemStyles","useDraggableWithDomApi","elRef","draggingElRef","onDragFinish","dragging","setDragging","useState","lastClientYRef","useRef","lastDragShiftYRef","scrollElRef","lastScrollTopRef","scrollControllerRef","initializeScrollRefs","draggableEl","node","current","scrollTop","cleanupScrollRefs","stop","lastDragDirectionRef","undefined","toggleDragDirection","prevShiftY","nextShiftY","shiftYDiff","itemStartIndexRef","itemEndIndexRef","draggingItemRef","placeholderItemRef","siblingItemsRef","itemsGapRef","initializeItems","draggingEl","draggingElRect","parentElement","parseInt","style","gridGap","children","Array","prototype","forEach","call","el","index","getAttribute","push","shifted","sibling","cleanupItems","swappedItemIndexRange","from","to","getShiftAndUnshiftItemsPreparedData","clientY","shiftItemEls","unshiftItemEls","siblingItem","isOverEl","isUnderEl","setShiftAndUnshiftItemStyles","item","schedulingAutoScrollTimeoutIdRef","clearSchedulingAutoScrollTimeout","clearTimeout","tryAutoScroll","shouldScrolling","y","schedulingAutoScroll","setTimeout","onDragStart","event","originalEvent","stopPropagation","preventDefault","onDragMove","shiftY","isRunning","prevDragging","onDragEnd","swappedItemRange","handleScroll","useCallback","nextScrollTop","scrollDiff","clientYWithScrollOffset","recalculateOnScroll","scrollEl","addEventListener","removeEventListener","componentWillUnmount"],"mappings":"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"}