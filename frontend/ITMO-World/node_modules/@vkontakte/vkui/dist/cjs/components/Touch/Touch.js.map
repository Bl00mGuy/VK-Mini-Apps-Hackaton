{"version":3,"sources":["../../../../src/components/Touch/Touch.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useStableCallback } from '../../hooks/useStableCallback';\nimport { getWindow, isHTMLElement } from '../../lib/dom';\nimport { coordX, coordY, touchEnabled, type VKUITouchEvent } from '../../lib/touch';\nimport type { HasComponent, HasRootRef } from '../../types';\n\nexport interface CustomTouchEvent extends Gesture {\n  originalEvent: VKUITouchEvent;\n}\n\nexport type HoverHandler = (outputEvent: MouseEvent) => void;\n\nexport type CustomTouchEventHandler = (event: CustomTouchEvent) => void;\n\nexport interface TouchProps\n  extends React.AllHTMLAttributes<HTMLElement>,\n    HasRootRef<HTMLElement>,\n    HasComponent {\n  /**\n   * Привязать onEnter и onLeave через pointer-events - работает на disabled-инпутах\n   */\n  usePointerHover?: boolean;\n  useCapture?: boolean;\n  slideThreshold?: number;\n  noSlideClick?: boolean;\n  onEnter?: HoverHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onLeave?: HoverHandler;\n  onStart?: CustomTouchEventHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onStartX?: CustomTouchEventHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onStartY?: CustomTouchEventHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onMove?: CustomTouchEventHandler;\n  onMoveX?: CustomTouchEventHandler;\n  onMoveY?: CustomTouchEventHandler;\n  onEnd?: CustomTouchEventHandler;\n  onEndX?: CustomTouchEventHandler;\n  onEndY?: CustomTouchEventHandler;\n  stopPropagation?: boolean;\n}\n\nexport interface Gesture {\n  startX: number;\n  startY: number;\n  startT: Date;\n  duration: number;\n  isPressed: boolean;\n  isY: boolean;\n  isX: boolean;\n  isSlideX: boolean;\n  isSlideY: boolean;\n  isSlide: boolean;\n  clientX: number;\n  clientY: number;\n  shiftX: number;\n  shiftY: number;\n  shiftXAbs: number;\n  shiftYAbs: number;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Touch\n */\nexport const Touch = ({\n  onStart,\n  onStartX,\n  onStartY,\n  onMove,\n  onMoveX,\n  onMoveY,\n  onEnter,\n  onLeave,\n  onEnd,\n  onEndX,\n  onEndY,\n  onClickCapture,\n  usePointerHover,\n  slideThreshold = 5,\n  useCapture = false,\n  Component = 'div',\n  getRootRef,\n  noSlideClick = false,\n  stopPropagation = false,\n  ...restProps\n}: TouchProps) => {\n  const [isTouchEnabled] = React.useState(touchEnabled);\n  const gestureRef = React.useRef<Gesture | null>(null);\n  const didSlide = React.useRef(false);\n  const disposeTargetNativeGestureEvents = React.useRef<VoidFunction | null>(null);\n\n  const cleanupTargetNativeGestureEvents = () => {\n    gestureRef.current = null;\n    if (disposeTargetNativeGestureEvents.current) {\n      disposeTargetNativeGestureEvents.current();\n      disposeTargetNativeGestureEvents.current = null;\n    }\n  };\n\n  React.useEffect(() => cleanupTargetNativeGestureEvents, []);\n\n  /**\n   * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onEnd`/`onEndX`/`onEndY`.\n   */\n  const handleNativePointerUp = useStableCallback((event: MouseEvent | TouchEvent) => {\n    const gesture = gestureRef.current;\n\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n\n    if (gesture.isPressed) {\n      dispatchUserHandlers(event, gesture, [onEnd, onEndX, onEndY], stopPropagation);\n    }\n\n    if (isTouchEnabled) {\n      // https://github.com/VKCOM/VKUI/issues/4414\n      // если тач-устройство и был зафиксирован touchmove,\n      // то событие клика не вызывается\n      if (gesture.isSlide) {\n        didSlide.current = false;\n      }\n      // Если это был тач-евент, симулируем отмену hover\n      if (onLeave) {\n        onLeave(event as MouseEvent);\n      }\n    } else {\n      didSlide.current = Boolean(gesture.isSlide);\n    }\n\n    cleanupTargetNativeGestureEvents();\n  });\n\n  /**\n   * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onMove`/`onMoveX`/`onMoveY`.\n   */\n  const handleNativePointerMove = useStableCallback((event: MouseEvent | TouchEvent) => {\n    const gesture = gestureRef.current;\n\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n\n    const clientX = coordX(event);\n    const clientY = coordY(event);\n\n    // смещения\n    const shiftX = clientX - gesture.startX;\n    const shiftY = clientY - gesture.startY;\n\n    // абсолютные значения смещений\n    const shiftXAbs = Math.abs(shiftX);\n    const shiftYAbs = Math.abs(shiftY);\n\n    // Если определяем мультитач, то прерываем жест\n    if ('touches' in event && event.touches.length > 1) {\n      return handleNativePointerUp(event);\n    }\n\n    // если мы ещё не определились\n    if (!gesture.isX && !gesture.isY) {\n      const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;\n      const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;\n      const willBeSlidedX = willBeX && (!!onMoveX || !!onMove);\n      const willBeSlidedY = willBeY && (!!onMoveY || !!onMove);\n\n      gesture.isY = willBeY;\n      gesture.isX = willBeX;\n      gesture.isSlideX = willBeSlidedX;\n      gesture.isSlideY = willBeSlidedY;\n      gesture.isSlide = willBeSlidedX || willBeSlidedY;\n    }\n\n    if (gesture.isSlide) {\n      gesture.clientX = clientX;\n      gesture.clientY = clientY;\n      gesture.shiftX = shiftX;\n      gesture.shiftY = shiftY;\n      gesture.shiftXAbs = shiftXAbs;\n      gesture.shiftYAbs = shiftYAbs;\n\n      dispatchUserHandlers(event, gesture, [onMove, onMoveX, onMoveY], stopPropagation);\n    }\n  });\n\n  const handlePointerDown = (\n    event: React.MouseEvent<HTMLElement> | React.TouchEvent<HTMLElement>,\n  ) => {\n    const nativeEvent = event.nativeEvent;\n\n    gestureRef.current = initGesture(coordX(nativeEvent), coordY(nativeEvent));\n\n    const shouldCallDirectionHandlerOnlyIsSlide = false;\n    dispatchUserHandlers(\n      event,\n      gestureRef.current,\n      [onStart, onStartX, onStartY],\n      stopPropagation,\n      shouldCallDirectionHandlerOnlyIsSlide,\n    );\n\n    const eventOptions = { capture: useCapture, passive: false };\n\n    // FIXME: заменить touch/mouse-события ниже на pointer-события после того, как бразуеры из\n    // .browserslistrc начнут поддерживать его (см. https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events#browser_compatibility).\n    if (isTouchEnabled) {\n      if (isHTMLElement(event.target)) {\n        // Тач-события не всплывают, поэтому навешиваем события на целевой элемент\n        // см. #235, #1968, https://stackoverflow.com/a/45760014\n        const target = event.target;\n\n        target.addEventListener('touchmove', handleNativePointerMove, eventOptions);\n        target.addEventListener('touchend', handleNativePointerUp, eventOptions);\n        target.addEventListener('touchcancel', handleNativePointerUp, eventOptions);\n\n        disposeTargetNativeGestureEvents.current = () => {\n          target.removeEventListener('touchmove', handleNativePointerMove, eventOptions);\n          target.removeEventListener('touchend', handleNativePointerUp, eventOptions);\n          target.removeEventListener('touchcancel', handleNativePointerUp, eventOptions);\n        };\n      }\n    } else {\n      // Используем события на Document, т.к. mouse-события на целевом элементе могут теряться при\n      // выходе за границы этого элемента.\n      const doc = getWindow(event.currentTarget).document;\n\n      doc.addEventListener('mousemove', handleNativePointerMove, eventOptions);\n      doc.addEventListener('mouseup', handleNativePointerUp, eventOptions);\n      doc.addEventListener('mouseleave', handleNativePointerUp, eventOptions);\n\n      disposeTargetNativeGestureEvents.current = () => {\n        doc.removeEventListener('mousemove', handleNativePointerMove, eventOptions);\n        doc.removeEventListener('mouseup', handleNativePointerUp, eventOptions);\n        doc.removeEventListener('mouseleave', handleNativePointerUp, eventOptions);\n      };\n    }\n  };\n\n  const handlePointerEnter = onEnter\n    ? (event: React.MouseEvent<HTMLElement>) => onEnter(event.nativeEvent)\n    : undefined;\n\n  const handlePointerLeave = onLeave\n    ? (event: React.MouseEvent<HTMLElement>) => onLeave(event.nativeEvent)\n    : undefined;\n\n  /**\n   * Отменяет нативное браузерное поведение для вложенных ссылок и изображений\n   */\n  const handleDragStart = (event: React.DragEvent<HTMLElement>) => {\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'A' || target.tagName === 'IMG') {\n      event.preventDefault();\n    }\n  };\n\n  /**\n   * Отменяет переход по вложенной ссылке, если был зафиксирован свайп\n   */\n  const handleClickCapture: typeof onClickCapture = (event) => {\n    if (!didSlide.current) {\n      return onClickCapture && onClickCapture(event);\n    }\n\n    if (noSlideClick) {\n      event.stopPropagation();\n\n      // https://github.com/VKCOM/VKUI/issues/1977\n      // https://github.com/VKCOM/VKUI/issues/3892\n      event.preventDefault();\n    } else {\n      onClickCapture && onClickCapture(event);\n    }\n\n    didSlide.current = false;\n  };\n\n  return (\n    <Component\n      {...restProps}\n      ref={getRootRef}\n      onDragStart={handleDragStart}\n      onClickCapture={handleClickCapture}\n      // onEnter\n      onPointerEnter={usePointerHover ? handlePointerEnter : undefined}\n      onMouseEnter={!usePointerHover ? handlePointerEnter : undefined}\n      // onLeave\n      onPointerLeave={usePointerHover ? handlePointerLeave : undefined}\n      onMouseLeave={!usePointerHover ? handlePointerLeave : undefined}\n      // handlePointerDown\n      onTouchStartCapture={isTouchEnabled && useCapture ? handlePointerDown : undefined}\n      onTouchStart={isTouchEnabled && !useCapture ? handlePointerDown : undefined}\n      onMouseDownCapture={!isTouchEnabled && useCapture ? handlePointerDown : undefined}\n      onMouseDown={!isTouchEnabled && !useCapture ? handlePointerDown : undefined}\n    />\n  );\n};\n\nfunction initGesture(startX: number, startY: number): Gesture {\n  return {\n    startX,\n    startY,\n    startT: new Date(),\n    duration: 0,\n    isPressed: true,\n    isY: false,\n    isX: false,\n    isSlideX: false,\n    isSlideY: false,\n    isSlide: false,\n    clientX: 0,\n    clientY: 0,\n    shiftX: 0,\n    shiftY: 0,\n    shiftXAbs: 0,\n    shiftYAbs: 0,\n  };\n}\n\ntype Handlers = [\n  CustomTouchEventHandler | undefined,\n  CustomTouchEventHandler | undefined,\n  CustomTouchEventHandler | undefined,\n];\n\nfunction dispatchUserHandlers(\n  event: MouseEvent | TouchEvent | React.MouseEvent | React.TouchEvent,\n  gesture: Gesture,\n  [handler, handlerX, handlerY]: Handlers,\n  stopPropagation?: boolean,\n  shouldCallDirectionHandlerOnlyIsSlide = true,\n) {\n  if (stopPropagation) {\n    event.stopPropagation();\n  }\n\n  const data = {\n    ...gesture,\n    originalEvent: event as unknown as VKUITouchEvent,\n    duration: Date.now() - gesture.startT.getTime(),\n  };\n\n  if (handler) {\n    handler(data);\n  }\n\n  if (handlerX) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideX) {\n        handlerX(data);\n      }\n    } else {\n      handlerX(data);\n    }\n  }\n\n  if (handlerY) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideY) {\n        handlerY(data);\n      }\n    } else {\n      handlerY(data);\n    }\n  }\n}\n"],"names":["Touch","onStart","onStartX","onStartY","onMove","onMoveX","onMoveY","onEnter","onLeave","onEnd","onEndX","onEndY","onClickCapture","usePointerHover","slideThreshold","useCapture","Component","getRootRef","noSlideClick","stopPropagation","restProps","isTouchEnabled","React","useState","touchEnabled","gestureRef","useRef","didSlide","disposeTargetNativeGestureEvents","cleanupTargetNativeGestureEvents","current","useEffect","handleNativePointerUp","useStableCallback","event","gesture","isPressed","dispatchUserHandlers","isSlide","Boolean","handleNativePointerMove","clientX","coordX","clientY","coordY","shiftX","startX","shiftY","startY","shiftXAbs","Math","abs","shiftYAbs","touches","length","isX","isY","willBeX","willBeY","willBeSlidedX","willBeSlidedY","isSlideX","isSlideY","handlePointerDown","nativeEvent","initGesture","shouldCallDirectionHandlerOnlyIsSlide","eventOptions","capture","passive","isHTMLElement","target","addEventListener","removeEventListener","doc","getWindow","currentTarget","document","handlePointerEnter","undefined","handlePointerLeave","handleDragStart","tagName","preventDefault","handleClickCapture","ref","onDragStart","onPointerEnter","onMouseEnter","onPointerLeave","onMouseLeave","onTouchStartCapture","onTouchStart","onMouseDownCapture","onMouseDown","startT","Date","duration","handler","handlerX","handlerY","data","originalEvent","now","getTime"],"mappings":"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"}