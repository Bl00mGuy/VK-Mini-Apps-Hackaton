{"version":3,"sources":["../../../../src/components/Clickable/useState.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { mergeCalls } from '../../lib/mergeCalls';\nimport { useStateWithDelay } from './useStateWithDelay';\n\nexport interface StateProps {\n  /**\n   * Указывает, должен ли компонент реагировать на hover-состояние\n   */\n  hasHover?: boolean;\n  /**\n   * Позволяет управлять hovered-состоянием извне\n   */\n  hovered?: boolean;\n  /**\n   * Позволяет управлять activated-состоянием извне\n   */\n  activated?: boolean;\n  /**\n   * Указывает, должен ли компонент реагировать на active-состояние\n   */\n  hasActive?: boolean;\n\n  /**\n   * Позволяет родительскому компоненту\n   * иметь hovered-cостояние при наведении\n   * на любой дочерний элемент.\n   * По умолчанию состояние hovered у родителя сбрасывается.\n   *\n   * Присваивается родителькому компоненту.\n   *\n   * @example\n   * <Tappable hasHoverWithChildren>\n   *   <IconButton />\n   *   <IconButton />\n   *   <IconButton />\n   * </Tappable>\n   */\n  hasHoverWithChildren?: boolean;\n\n  /**\n   * Позволяет родительскому компоненту показывать hovered-состояние при наведении\n   * на текущий дочерний компонент.\n   *\n   * Присваивается дочернему компоненту.\n   *\n   * @example\n   * <Tappable>\n   *   <IconButton unlockParentHover />\n   *   <IconButton unlockParentHover />\n   *   <IconButton />\n   * </Tappable>\n   */\n  unlockParentHover?: boolean;\n\n  /**\n   * Длительность показа `activated`-состояния\n   */\n  activeEffectDelay?: number;\n\n  /**\n   * Стиль подсветки active-состояния\n   */\n  activeClassName?: string;\n\n  /**\n   * Стиль подсветки hover-состояния\n   */\n  hoverClassName?: string;\n}\n\nexport const DEFAULT_ACTIVE_EFFECT_DELAY = 600;\n\nconst ACTIVE_DELAY = 70;\n\ninterface UseHoverProps extends Pick<StateProps, 'hovered' | 'hasHover'> {\n  /**\n   * Блокирование активации состояний\n   */\n  lockState: boolean;\n  setParentStateLock: (v: boolean) => void;\n}\n\n/**\n * Управляет наведением на компонент, игнорирует тач события\n */\nfunction useHover({ hovered, hasHover = true, lockState, setParentStateLock }: UseHoverProps) {\n  const [hoveredStateLocal, setHoveredStateLocal] = React.useState(false);\n\n  const prevIsHoveredRef = React.useRef<boolean | undefined>(undefined);\n\n  const handleHover = React.useCallback(\n    (isHover: boolean) => {\n      setHoveredStateLocal(isHover);\n\n      const isHovered = calculateStateValue({\n        hasState: hasHover,\n        isLocked: lockState,\n        stateValueControlled: Boolean(hovered),\n        stateValueLocal: isHover,\n      });\n\n      // проверка сделана чтобы реже вызывать обновление состояния\n      // контекста родителя\n      if (isHovered !== prevIsHoveredRef.current) {\n        prevIsHoveredRef.current = isHovered;\n        setParentStateLock(isHovered);\n      }\n    },\n    [setParentStateLock, hasHover, hovered, lockState],\n  );\n\n  const onPointerEnter: React.PointerEventHandler<any> = (e) => {\n    if (e.pointerType === 'touch') {\n      return;\n    }\n\n    handleHover(true);\n  };\n\n  const onPointerLeave = () => {\n    handleHover(false);\n  };\n\n  const isHovered = calculateStateValue({\n    hasState: hasHover,\n    isLocked: lockState,\n    stateValueControlled: Boolean(hovered),\n    stateValueLocal: hoveredStateLocal,\n  });\n\n  return {\n    isHovered,\n    onPointerEnter: hasHover ? onPointerEnter : noop,\n    onPointerLeave: hasHover ? onPointerLeave : noop,\n  };\n}\n\ninterface UseActiveProps extends Pick<StateProps, 'activated' | 'activeEffectDelay' | 'hasActive'> {\n  /**\n   * Блокирование активации состояний\n   */\n  lockStateRef: React.MutableRefObject<boolean>;\n  setParentStateLock: (v: boolean) => void;\n}\n\n/**\n * Управляет активацией компонента\n */\nfunction useActive({\n  activated,\n  activeEffectDelay,\n  hasActive = true,\n  lockStateRef,\n  setParentStateLock,\n}: UseActiveProps) {\n  // передаём setParentStateLock, чтобы функция вызывалась вместе с установкой стейта,\n  // если установка отложена c помощью delay, то и вызов будет отложен\n  const [activatedState, setActivated] = useStateWithDelay<boolean>(false, 0, setParentStateLock);\n\n  // Список нажатий которые не требуется отменять\n  const pointersUp = React.useMemo(() => new Set<number>(), []);\n\n  const onPointerDown = () => {\n    if (lockStateRef.current) {\n      return;\n    }\n\n    setActivated(true, ACTIVE_DELAY);\n    // намеренно выставляем lock, так как setActivated вызов отложен\n    // а у отложенного setActivated setParentStateLock тоже вызовится отложенно\n    // родитель сейчас тоже обработает это же событие PointerDown\n    // если мы не залочим activatedState у родителя сейчас, то родитель выставит active состояние\n    setParentStateLock(true);\n  };\n\n  const onPointerCancel: React.PointerEventHandler = (e) => {\n    if (pointersUp.has(e.pointerId)) {\n      pointersUp.delete(e.pointerId);\n      return;\n    }\n\n    setActivated(false);\n  };\n\n  const onPointerUp: React.PointerEventHandler = (e) => {\n    pointersUp.add(e.pointerId);\n\n    if (lockStateRef.current) {\n      return;\n    }\n\n    setActivated(true);\n    setActivated(false, activeEffectDelay);\n  };\n\n  const isActivated = calculateStateValue({\n    hasState: hasActive,\n    isLocked: lockStateRef.current,\n    stateValueControlled: Boolean(activated),\n    stateValueLocal: activatedState,\n  });\n\n  return {\n    isActivated,\n    onPointerLeave: hasActive ? onPointerCancel : noop,\n    onPointerDown: hasActive ? onPointerDown : noop,\n    onPointerCancel: hasActive ? onPointerCancel : noop,\n    onPointerUp: hasActive ? onPointerUp : noop,\n  };\n}\n\ninterface ClickableLockStateContextInterface {\n  lockHoverStateBubbling?: (v: boolean) => void;\n  lockActiveStateBubbling?: (v: boolean) => void;\n}\n\nexport const ClickableLockStateContext: React.Context<ClickableLockStateContextInterface> =\n  React.createContext<ClickableLockStateContextInterface>({\n    lockHoverStateBubbling: undefined,\n    lockActiveStateBubbling: undefined,\n  });\n\n/**\n * Блокирует стейт на всплытие\n */\nfunction useLockState(\n  setParentStateLockBubbling: (v: boolean) => void,\n): readonly [boolean, (v: boolean) => void, (...args: any[]) => void] {\n  const [lockState, setLockState] = React.useState(false);\n\n  const setStateLockBubblingImmediate = React.useCallback(\n    (isLock: boolean) => {\n      setLockState(isLock);\n      setParentStateLockBubbling(isLock);\n    },\n    [setParentStateLockBubbling],\n  );\n\n  return [lockState, setParentStateLockBubbling, setStateLockBubblingImmediate] as const;\n}\n\nfunction useLockRef(\n  setParentStateLockBubbling: (v: boolean) => void,\n): readonly [React.MutableRefObject<boolean>, (v: boolean) => void, (...args: any[]) => void] {\n  const lockStateRef = React.useRef(false);\n\n  const setStateLockBubblingImmediate = React.useCallback(\n    (isLock: boolean) => {\n      lockStateRef.current = isLock;\n      setParentStateLockBubbling(isLock);\n    },\n    [setParentStateLockBubbling],\n  );\n\n  return [lockStateRef, setParentStateLockBubbling, setStateLockBubblingImmediate] as const;\n}\n\n/**\n * Управляет состоянием компонента\n */\nexport function useState({\n  hovered,\n  hasHover,\n  hasActive,\n  unlockParentHover,\n  ...restProps\n}: StateProps): {\n  stateClassName: string;\n  setLockHoverBubblingImmediate: (...args: any[]) => void;\n  setLockActiveBubblingImmediate: (...args: any[]) => void;\n} {\n  const { lockHoverStateBubbling = noop, lockActiveStateBubbling = noop } =\n    React.useContext(ClickableLockStateContext);\n\n  const [lockHoverState, setParentStateLockHoverBubbling, setLockHoverBubblingImmediate] =\n    useLockState(unlockParentHover ? noop : lockHoverStateBubbling);\n  const [lockActiveStateRef, setParentStateLockActiveBubbling, setLockActiveBubblingImmediate] =\n    useLockRef(lockActiveStateBubbling);\n\n  const { isHovered, ...hoverEvent } = useHover({\n    hasHover,\n    hovered,\n    lockState: lockHoverState,\n    setParentStateLock: setParentStateLockHoverBubbling,\n  });\n\n  const { isActivated, ...activeEvent } = useActive({\n    ...restProps,\n    lockStateRef: lockActiveStateRef,\n    setParentStateLock: setParentStateLockActiveBubbling,\n  });\n\n  const stateClassName = classNames(\n    isHovered && restProps.hoverClassName,\n    isActivated && restProps.activeClassName,\n  );\n  const handlers = mergeCalls(hoverEvent, activeEvent);\n\n  return {\n    stateClassName,\n    setLockHoverBubblingImmediate,\n    setLockActiveBubblingImmediate,\n    ...handlers,\n  };\n}\n\n// Общая функция для определения конечного состояния active/hovered\nfunction calculateStateValue({\n  hasState,\n  isLocked,\n  stateValueControlled,\n  stateValueLocal,\n}: {\n  hasState: boolean;\n  isLocked: boolean;\n  stateValueControlled: boolean;\n  stateValueLocal: boolean;\n}): boolean {\n  return hasState && !isLocked && (stateValueControlled || stateValueLocal);\n}\n"],"names":["ClickableLockStateContext","DEFAULT_ACTIVE_EFFECT_DELAY","useState","ACTIVE_DELAY","useHover","hovered","hasHover","lockState","setParentStateLock","hoveredStateLocal","setHoveredStateLocal","React","prevIsHoveredRef","useRef","undefined","handleHover","useCallback","isHover","isHovered","calculateStateValue","hasState","isLocked","stateValueControlled","Boolean","stateValueLocal","current","onPointerEnter","e","pointerType","onPointerLeave","noop","useActive","activated","activeEffectDelay","hasActive","lockStateRef","activatedState","setActivated","useStateWithDelay","pointersUp","useMemo","Set","onPointerDown","onPointerCancel","has","pointerId","delete","onPointerUp","add","isActivated","createContext","lockHoverStateBubbling","lockActiveStateBubbling","useLockState","setParentStateLockBubbling","setLockState","setStateLockBubblingImmediate","isLock","useLockRef","unlockParentHover","restProps","useContext","lockHoverState","setParentStateLockHoverBubbling","setLockHoverBubblingImmediate","lockActiveStateRef","setParentStateLockActiveBubbling","setLockActiveBubblingImmediate","hoverEvent","activeEvent","stateClassName","classNames","hoverClassName","activeClassName","handlers","mergeCalls"],"mappings":";;;;;;;;;;;IAyNaA,yBAAyB;eAAzBA;;IAlJAC,2BAA2B;eAA3BA;;IA8LGC,QAAQ;eAARA;;;;;;;iEArQO;sBACU;4BACN;mCACO;AAoE3B,MAAMD,8BAA8B;AAE3C,MAAME,eAAe;AAUrB;;CAEC,GACD,SAASC,SAAS,EAAEC,OAAO,EAAEC,WAAW,IAAI,EAAEC,SAAS,EAAEC,kBAAkB,EAAiB;IAC1F,MAAM,CAACC,mBAAmBC,qBAAqB,GAAGC,OAAMT,QAAQ,CAAC;IAEjE,MAAMU,mBAAmBD,OAAME,MAAM,CAAsBC;IAE3D,MAAMC,cAAcJ,OAAMK,WAAW,CACnC,CAACC;QACCP,qBAAqBO;QAErB,MAAMC,YAAYC,oBAAoB;YACpCC,UAAUd;YACVe,UAAUd;YACVe,sBAAsBC,QAAQlB;YAC9BmB,iBAAiBP;QACnB;QAEA,4DAA4D;QAC5D,qBAAqB;QACrB,IAAIC,cAAcN,iBAAiBa,OAAO,EAAE;YAC1Cb,iBAAiBa,OAAO,GAAGP;YAC3BV,mBAAmBU;QACrB;IACF,GACA;QAACV;QAAoBF;QAAUD;QAASE;KAAU;IAGpD,MAAMmB,iBAAiD,CAACC;QACtD,IAAIA,EAAEC,WAAW,KAAK,SAAS;YAC7B;QACF;QAEAb,YAAY;IACd;IAEA,MAAMc,iBAAiB;QACrBd,YAAY;IACd;IAEA,MAAMG,YAAYC,oBAAoB;QACpCC,UAAUd;QACVe,UAAUd;QACVe,sBAAsBC,QAAQlB;QAC9BmB,iBAAiBf;IACnB;IAEA,OAAO;QACLS;QACAQ,gBAAgBpB,WAAWoB,iBAAiBI,UAAI;QAChDD,gBAAgBvB,WAAWuB,iBAAiBC,UAAI;IAClD;AACF;AAUA;;CAEC,GACD,SAASC,UAAU,EACjBC,SAAS,EACTC,iBAAiB,EACjBC,YAAY,IAAI,EAChBC,YAAY,EACZ3B,kBAAkB,EACH;IACf,oFAAoF;IACpF,oEAAoE;IACpE,MAAM,CAAC4B,gBAAgBC,aAAa,GAAGC,IAAAA,oCAAiB,EAAU,OAAO,GAAG9B;IAE5E,+CAA+C;IAC/C,MAAM+B,aAAa5B,OAAM6B,OAAO,CAAC,IAAM,IAAIC,OAAe,EAAE;IAE5D,MAAMC,gBAAgB;QACpB,IAAIP,aAAaV,OAAO,EAAE;YACxB;QACF;QAEAY,aAAa,MAAMlC;QACnB,gEAAgE;QAChE,2EAA2E;QAC3E,6DAA6D;QAC7D,6FAA6F;QAC7FK,mBAAmB;IACrB;IAEA,MAAMmC,kBAA6C,CAAChB;QAClD,IAAIY,WAAWK,GAAG,CAACjB,EAAEkB,SAAS,GAAG;YAC/BN,WAAWO,MAAM,CAACnB,EAAEkB,SAAS;YAC7B;QACF;QAEAR,aAAa;IACf;IAEA,MAAMU,cAAyC,CAACpB;QAC9CY,WAAWS,GAAG,CAACrB,EAAEkB,SAAS;QAE1B,IAAIV,aAAaV,OAAO,EAAE;YACxB;QACF;QAEAY,aAAa;QACbA,aAAa,OAAOJ;IACtB;IAEA,MAAMgB,cAAc9B,oBAAoB;QACtCC,UAAUc;QACVb,UAAUc,aAAaV,OAAO;QAC9BH,sBAAsBC,QAAQS;QAC9BR,iBAAiBY;IACnB;IAEA,OAAO;QACLa;QACApB,gBAAgBK,YAAYS,kBAAkBb,UAAI;QAClDY,eAAeR,YAAYQ,gBAAgBZ,UAAI;QAC/Ca,iBAAiBT,YAAYS,kBAAkBb,UAAI;QACnDiB,aAAab,YAAYa,cAAcjB,UAAI;IAC7C;AACF;AAOO,MAAM9B,0CACXW,OAAMuC,aAAa,CAAqC;IACtDC,wBAAwBrC;IACxBsC,yBAAyBtC;AAC3B;AAEF;;CAEC,GACD,SAASuC,aACPC,0BAAgD;IAEhD,MAAM,CAAC/C,WAAWgD,aAAa,GAAG5C,OAAMT,QAAQ,CAAC;IAEjD,MAAMsD,gCAAgC7C,OAAMK,WAAW,CACrD,CAACyC;QACCF,aAAaE;QACbH,2BAA2BG;IAC7B,GACA;QAACH;KAA2B;IAG9B,OAAO;QAAC/C;QAAW+C;QAA4BE;KAA8B;AAC/E;AAEA,SAASE,WACPJ,0BAAgD;IAEhD,MAAMnB,eAAexB,OAAME,MAAM,CAAC;IAElC,MAAM2C,gCAAgC7C,OAAMK,WAAW,CACrD,CAACyC;QACCtB,aAAaV,OAAO,GAAGgC;QACvBH,2BAA2BG;IAC7B,GACA;QAACH;KAA2B;IAG9B,OAAO;QAACnB;QAAcmB;QAA4BE;KAA8B;AAClF;AAKO,SAAStD,SAAS;QAAA,EACvBG,OAAO,EACPC,QAAQ,EACR4B,SAAS,EACTyB,iBAAiB,EAEN,GANY,QAKpBC,yCALoB;QACvBvD;QACAC;QACA4B;QACAyB;;IAOA,MAAM,EAAER,yBAAyBrB,UAAI,EAAEsB,0BAA0BtB,UAAI,EAAE,GACrEnB,OAAMkD,UAAU,CAAC7D;IAEnB,MAAM,CAAC8D,gBAAgBC,iCAAiCC,8BAA8B,GACpFX,aAAaM,oBAAoB7B,UAAI,GAAGqB;IAC1C,MAAM,CAACc,oBAAoBC,kCAAkCC,+BAA+B,GAC1FT,WAAWN;IAEb,MAAqChD,YAAAA,SAAS;QAC5CE;QACAD;QACAE,WAAWuD;QACXtD,oBAAoBuD;IACtB,IALM,EAAE7C,SAAS,EAAiB,GAAGd,WAAfgE,0CAAehE;QAA7Bc;;IAOR,MAAwCa,aAAAA,UAAU,4CAC7C6B;QACHzB,cAAc8B;QACdzD,oBAAoB0D;SAHhB,EAAEjB,WAAW,EAAkB,GAAGlB,YAAhBsC,2CAAgBtC;QAAhCkB;;IAMR,MAAMqB,iBAAiBC,IAAAA,gBAAU,EAC/BrD,aAAa0C,UAAUY,cAAc,EACrCvB,eAAeW,UAAUa,eAAe;IAE1C,MAAMC,WAAWC,IAAAA,sBAAU,EAACP,YAAYC;IAExC,OAAO;QACLC;QACAN;QACAG;OACGO;AAEP;AAEA,mEAAmE;AACnE,SAASvD,oBAAoB,EAC3BC,QAAQ,EACRC,QAAQ,EACRC,oBAAoB,EACpBE,eAAe,EAMhB;IACC,OAAOJ,YAAY,CAACC,YAAaC,CAAAA,wBAAwBE,eAAc;AACzE"}