{"version":3,"sources":["../../../../src/components/Tappable/Ripple.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, hasMouse as hasPointerLib, noop } from '@vkontakte/vkjs';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { getOffsetRect } from '../../lib/offset';\nimport styles from './Tappable.module.css';\n\n/**\n * Возможно нужен Ripple эффект. Данный хук нужен для отказа\n * от двойного ререндера.\n */\nexport const useMaybeNeedRipple = (\n  activeMode: string,\n  hasPointer: boolean | undefined,\n): boolean => {\n  const platform = usePlatform();\n\n  return platform === 'android' && !hasPointer && activeMode === 'background';\n};\n\ninterface Wave {\n  x: number;\n  y: number;\n  id: number;\n  pointerId: number;\n}\n\nconst DELAY = 70;\nconst WAVE_LIVE = 225;\n\n/**\n * Хук для создания Ripple эффектов\n */\nexport const useRipple = (\n  needRipple: boolean,\n  hasPointerContext: boolean | undefined,\n): {\n  clicks: Wave[];\n  onPointerDown: React.PointerEventHandler<HTMLSpanElement>;\n  onPointerCancel: React.PointerEventHandler<HTMLSpanElement>;\n} => {\n  const [clicks, setClicks] = React.useState<Wave[]>([]);\n\n  /**\n   * Коллекция нажатий и таймеров задержки появления волны\n   */\n  const pointerDelayTimers = React.useMemo(\n    () => new Map<number, ReturnType<typeof setTimeout>>(),\n    [],\n  );\n\n  React.useEffect(\n    function setClearClicksTimeout() {\n      const clicksTimeoutId = clicks.length > 0 ? setTimeout(() => setClicks([]), WAVE_LIVE) : null;\n      return function cancelClearClicksTimeout() {\n        if (clicksTimeoutId) {\n          clearTimeout(clicksTimeoutId);\n        }\n      };\n    },\n    [clicks],\n  );\n\n  function addClick(x: number, y: number, pointerId: number) {\n    const dateNow = Date.now();\n    const filteredClicks = clicks.filter((click) => click.id + WAVE_LIVE > dateNow);\n\n    setClicks([...filteredClicks, { x, y, id: dateNow, pointerId }]);\n    pointerDelayTimers.delete(pointerId);\n  }\n\n  /**\n   * Добавляем волну с задержкой. Задержка необходима при отмене волны.\n   */\n  const onPointerDown: React.PointerEventHandler<HTMLSpanElement> = (e) => {\n    const { top, left } = getOffsetRect(e.currentTarget);\n    const x = e.clientX - (left ?? 0);\n    const y = e.clientY - (top ?? 0);\n\n    pointerDelayTimers.set(\n      e.pointerId,\n      setTimeout(() => addClick(x, y, e.pointerId), DELAY),\n    );\n  };\n\n  const onPointerCancel: React.PointerEventHandler<HTMLSpanElement> = (e) => {\n    const timer = pointerDelayTimers.get(e.pointerId);\n    clearTimeout(timer);\n    pointerDelayTimers.delete(e.pointerId);\n  };\n\n  // WARNING: не использовать для рендеринга\n  const reallyNeedRipple = (!hasPointerLib || hasPointerContext === false) && needRipple;\n\n  return {\n    clicks,\n    onPointerDown: reallyNeedRipple ? onPointerDown : noop,\n    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop,\n  };\n};\n\nexport interface RippleProps {\n  needRipple: boolean;\n  clicks: Wave[];\n}\n\nexport const Ripple = ({ needRipple = true, clicks }: RippleProps): React.ReactNode => {\n  return (\n    <span\n      aria-hidden\n      className={classNames(\n        styles['Tappable__stateLayer'],\n        needRipple && styles['Tappable__ripple'],\n      )}\n    >\n      {clicks.map((wave) => (\n        <span\n          key={wave.id}\n          className={styles['Tappable__wave']}\n          style={{ top: wave.y, left: wave.x }}\n        />\n      ))}\n    </span>\n  );\n};\n"],"names":["Ripple","useMaybeNeedRipple","useRipple","activeMode","hasPointer","platform","usePlatform","DELAY","WAVE_LIVE","needRipple","hasPointerContext","clicks","setClicks","React","useState","pointerDelayTimers","useMemo","Map","useEffect","setClearClicksTimeout","clicksTimeoutId","length","setTimeout","cancelClearClicksTimeout","clearTimeout","addClick","x","y","pointerId","dateNow","Date","now","filteredClicks","filter","click","id","delete","onPointerDown","e","top","left","getOffsetRect","currentTarget","clientX","clientY","set","onPointerCancel","timer","get","reallyNeedRipple","hasPointerLib","noop","span","aria-hidden","className","classNames","map","wave","style"],"mappings":";;;;;;;;;;;IAyGaA,MAAM;eAANA;;IA/FAC,kBAAkB;eAAlBA;;IAsBAC,SAAS;eAATA;;;;;iEAhCU;sBACqC;6BAChC;wBACE;AAOvB,MAAMD,qBAAqB,CAChCE,YACAC;IAEA,MAAMC,WAAWC,IAAAA,wBAAW;IAE5B,OAAOD,aAAa,aAAa,CAACD,cAAcD,eAAe;AACjE;AASA,MAAMI,QAAQ;AACd,MAAMC,YAAY;AAKX,MAAMN,YAAY,CACvBO,YACAC;IAMA,MAAM,CAACC,QAAQC,UAAU,GAAGC,OAAMC,QAAQ,CAAS,EAAE;IAErD;;GAEC,GACD,MAAMC,qBAAqBF,OAAMG,OAAO,CACtC,IAAM,IAAIC,OACV,EAAE;IAGJJ,OAAMK,SAAS,CACb,SAASC;QACP,MAAMC,kBAAkBT,OAAOU,MAAM,GAAG,IAAIC,WAAW,IAAMV,UAAU,EAAE,GAAGJ,aAAa;QACzF,OAAO,SAASe;YACd,IAAIH,iBAAiB;gBACnBI,aAAaJ;YACf;QACF;IACF,GACA;QAACT;KAAO;IAGV,SAASc,SAASC,CAAS,EAAEC,CAAS,EAAEC,SAAiB;QACvD,MAAMC,UAAUC,KAAKC,GAAG;QACxB,MAAMC,iBAAiBrB,OAAOsB,MAAM,CAAC,CAACC,QAAUA,MAAMC,EAAE,GAAG3B,YAAYqB;QAEvEjB,UAAU;eAAIoB;YAAgB;gBAAEN;gBAAGC;gBAAGQ,IAAIN;gBAASD;YAAU;SAAE;QAC/Db,mBAAmBqB,MAAM,CAACR;IAC5B;IAEA;;GAEC,GACD,MAAMS,gBAA4D,CAACC;QACjE,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGC,IAAAA,qBAAa,EAACH,EAAEI,aAAa;QACnD,MAAMhB,IAAIY,EAAEK,OAAO,GAAIH,CAAAA,iBAAAA,kBAAAA,OAAQ,CAAA;QAC/B,MAAMb,IAAIW,EAAEM,OAAO,GAAIL,CAAAA,gBAAAA,iBAAAA,MAAO,CAAA;QAE9BxB,mBAAmB8B,GAAG,CACpBP,EAAEV,SAAS,EACXN,WAAW,IAAMG,SAASC,GAAGC,GAAGW,EAAEV,SAAS,GAAGrB;IAElD;IAEA,MAAMuC,kBAA8D,CAACR;QACnE,MAAMS,QAAQhC,mBAAmBiC,GAAG,CAACV,EAAEV,SAAS;QAChDJ,aAAauB;QACbhC,mBAAmBqB,MAAM,CAACE,EAAEV,SAAS;IACvC;IAEA,0CAA0C;IAC1C,MAAMqB,mBAAmB,AAAC,CAAA,CAACC,cAAa,IAAIxC,sBAAsB,KAAI,KAAMD;IAE5E,OAAO;QACLE;QACA0B,eAAeY,mBAAmBZ,gBAAgBc,UAAI;QACtDL,iBAAiBG,mBAAmBH,kBAAkBK,UAAI;IAC5D;AACF;AAOO,MAAMnD,SAAS,CAAC,EAAES,aAAa,IAAI,EAAEE,MAAM,EAAe;IAC/D,qBACE,qBAACyC;QACCC,aAAW;QACXC,WAAWC,IAAAA,gBAAU,8BAEnB9C;kBAGDE,OAAO6C,GAAG,CAAC,CAACC,qBACX,qBAACL;gBAECE,SAAS;gBACTI,OAAO;oBAAEnB,KAAKkB,KAAK9B,CAAC;oBAAEa,MAAMiB,KAAK/B,CAAC;gBAAC;eAF9B+B,KAAKtB,EAAE;;AAOtB"}