{"version":3,"sources":["../../../../src/components/Tappable/Ripple.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, hasMouse as hasPointerLib, noop } from '@vkontakte/vkjs';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { getOffsetRect } from '../../lib/offset';\nimport styles from './Tappable.module.css';\n\n/**\n * Возможно нужен Ripple эффект. Данный хук нужен для отказа\n * от двойного ререндера.\n */\nexport const useMaybeNeedRipple = (\n  activeMode: string,\n  hasPointer: boolean | undefined,\n): boolean => {\n  const platform = usePlatform();\n\n  return platform === 'android' && !hasPointer && activeMode === 'background';\n};\n\ninterface Wave {\n  x: number;\n  y: number;\n  id: number;\n  pointerId: number;\n}\n\nconst DELAY = 70;\nconst WAVE_LIVE = 225;\n\n/**\n * Хук для создания Ripple эффектов\n */\nexport const useRipple = (\n  needRipple: boolean,\n  hasPointerContext: boolean | undefined,\n): {\n  clicks: Wave[];\n  onPointerDown: React.PointerEventHandler<HTMLSpanElement>;\n  onPointerCancel: React.PointerEventHandler<HTMLSpanElement>;\n} => {\n  const [clicks, setClicks] = React.useState<Wave[]>([]);\n\n  /**\n   * Коллекция нажатий и таймеров задержки появления волны\n   */\n  const pointerDelayTimers = React.useMemo(\n    () => new Map<number, ReturnType<typeof setTimeout>>(),\n    [],\n  );\n\n  React.useEffect(\n    function setClearClicksTimeout() {\n      const clicksTimeoutId = clicks.length > 0 ? setTimeout(() => setClicks([]), WAVE_LIVE) : null;\n      return function cancelClearClicksTimeout() {\n        if (clicksTimeoutId) {\n          clearTimeout(clicksTimeoutId);\n        }\n      };\n    },\n    [clicks],\n  );\n\n  function addClick(x: number, y: number, pointerId: number) {\n    const dateNow = Date.now();\n    const filteredClicks = clicks.filter((click) => click.id + WAVE_LIVE > dateNow);\n\n    setClicks([...filteredClicks, { x, y, id: dateNow, pointerId }]);\n    pointerDelayTimers.delete(pointerId);\n  }\n\n  /**\n   * Добавляем волну с задержкой. Задержка необходима при отмене волны.\n   */\n  const onPointerDown: React.PointerEventHandler<HTMLSpanElement> = (e) => {\n    const { top, left } = getOffsetRect(e.currentTarget);\n    const x = e.clientX - (left ?? 0);\n    const y = e.clientY - (top ?? 0);\n\n    pointerDelayTimers.set(\n      e.pointerId,\n      setTimeout(() => addClick(x, y, e.pointerId), DELAY),\n    );\n  };\n\n  const onPointerCancel: React.PointerEventHandler<HTMLSpanElement> = (e) => {\n    const timer = pointerDelayTimers.get(e.pointerId);\n    clearTimeout(timer);\n    pointerDelayTimers.delete(e.pointerId);\n  };\n\n  // WARNING: не использовать для рендеринга\n  const reallyNeedRipple = (!hasPointerLib || hasPointerContext === false) && needRipple;\n\n  return {\n    clicks,\n    onPointerDown: reallyNeedRipple ? onPointerDown : noop,\n    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop,\n  };\n};\n\nexport interface RippleProps {\n  needRipple: boolean;\n  clicks: Wave[];\n}\n\nexport const Ripple = ({ needRipple = true, clicks }: RippleProps): React.ReactNode => {\n  return (\n    <span\n      aria-hidden\n      className={classNames(\n        styles['Tappable__stateLayer'],\n        needRipple && styles['Tappable__ripple'],\n      )}\n    >\n      {clicks.map((wave) => (\n        <span\n          key={wave.id}\n          className={styles['Tappable__wave']}\n          style={{ top: wave.y, left: wave.x }}\n        />\n      ))}\n    </span>\n  );\n};\n"],"names":["React","classNames","hasMouse","hasPointerLib","noop","usePlatform","getOffsetRect","styles","useMaybeNeedRipple","activeMode","hasPointer","platform","DELAY","WAVE_LIVE","useRipple","needRipple","hasPointerContext","clicks","setClicks","useState","pointerDelayTimers","useMemo","Map","useEffect","setClearClicksTimeout","clicksTimeoutId","length","setTimeout","cancelClearClicksTimeout","clearTimeout","addClick","x","y","pointerId","dateNow","Date","now","filteredClicks","filter","click","id","delete","onPointerDown","e","top","left","currentTarget","clientX","clientY","set","onPointerCancel","timer","get","reallyNeedRipple","Ripple","span","aria-hidden","className","map","wave","style"],"mappings":";AAAA,YAAYA,WAAW,QAAQ;AAC/B,SAASC,UAAU,EAAEC,YAAYC,aAAa,EAAEC,IAAI,QAAQ,kBAAkB;AAC9E,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,aAAa,QAAQ,mBAAmB;AACjD,OAAOC,YAAY,wBAAwB;AAE3C;;;CAGC,GACD,OAAO,MAAMC,qBAAqB,CAChCC,YACAC;IAEA,MAAMC,WAAWN;IAEjB,OAAOM,aAAa,aAAa,CAACD,cAAcD,eAAe;AACjE,EAAE;AASF,MAAMG,QAAQ;AACd,MAAMC,YAAY;AAElB;;CAEC,GACD,OAAO,MAAMC,YAAY,CACvBC,YACAC;IAMA,MAAM,CAACC,QAAQC,UAAU,GAAGlB,MAAMmB,QAAQ,CAAS,EAAE;IAErD;;GAEC,GACD,MAAMC,qBAAqBpB,MAAMqB,OAAO,CACtC,IAAM,IAAIC,OACV,EAAE;IAGJtB,MAAMuB,SAAS,CACb,SAASC;QACP,MAAMC,kBAAkBR,OAAOS,MAAM,GAAG,IAAIC,WAAW,IAAMT,UAAU,EAAE,GAAGL,aAAa;QACzF,OAAO,SAASe;YACd,IAAIH,iBAAiB;gBACnBI,aAAaJ;YACf;QACF;IACF,GACA;QAACR;KAAO;IAGV,SAASa,SAASC,CAAS,EAAEC,CAAS,EAAEC,SAAiB;QACvD,MAAMC,UAAUC,KAAKC,GAAG;QACxB,MAAMC,iBAAiBpB,OAAOqB,MAAM,CAAC,CAACC,QAAUA,MAAMC,EAAE,GAAG3B,YAAYqB;QAEvEhB,UAAU;eAAImB;YAAgB;gBAAEN;gBAAGC;gBAAGQ,IAAIN;gBAASD;YAAU;SAAE;QAC/Db,mBAAmBqB,MAAM,CAACR;IAC5B;IAEA;;GAEC,GACD,MAAMS,gBAA4D,CAACC;QACjE,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGvC,cAAcqC,EAAEG,aAAa;QACnD,MAAMf,IAAIY,EAAEI,OAAO,GAAIF,CAAAA,QAAQ,CAAA;QAC/B,MAAMb,IAAIW,EAAEK,OAAO,GAAIJ,CAAAA,OAAO,CAAA;QAE9BxB,mBAAmB6B,GAAG,CACpBN,EAAEV,SAAS,EACXN,WAAW,IAAMG,SAASC,GAAGC,GAAGW,EAAEV,SAAS,GAAGrB;IAElD;IAEA,MAAMsC,kBAA8D,CAACP;QACnE,MAAMQ,QAAQ/B,mBAAmBgC,GAAG,CAACT,EAAEV,SAAS;QAChDJ,aAAasB;QACb/B,mBAAmBqB,MAAM,CAACE,EAAEV,SAAS;IACvC;IAEA,0CAA0C;IAC1C,MAAMoB,mBAAmB,AAAC,CAAA,CAAClD,iBAAiBa,sBAAsB,KAAI,KAAMD;IAE5E,OAAO;QACLE;QACAyB,eAAeW,mBAAmBX,gBAAgBtC;QAClD8C,iBAAiBG,mBAAmBH,kBAAkB9C;IACxD;AACF,EAAE;AAOF,OAAO,MAAMkD,SAAS,CAAC,EAAEvC,aAAa,IAAI,EAAEE,MAAM,EAAe;IAC/D,qBACE,KAACsC;QACCC,aAAW;QACXC,WAAWxD,WACTM,MAAM,CAAC,uBAAuB,EAC9BQ,cAAcR,MAAM,CAAC,mBAAmB;kBAGzCU,OAAOyC,GAAG,CAAC,CAACC,qBACX,KAACJ;gBAECE,WAAWlD,MAAM,CAAC,iBAAiB;gBACnCqD,OAAO;oBAAEhB,KAAKe,KAAK3B,CAAC;oBAAEa,MAAMc,KAAK5B,CAAC;gBAAC;eAF9B4B,KAAKnB,EAAE;;AAOtB,EAAE"}