import * as React from 'react';
type DispatchWithDelay<S> = (value: S, delay?: number) => void;
/**
 * Возвращает значение с состоянием и функции на обновление состояния
 * без и с задержкой.
 *
 * # Пример
 *
 * ```ts
 * const [count, setCount] = useStateWithDelay(initialState);
 *
 * const click = () => {
 *   setCount(count + 1, 500)
 * }
 * ```
 *
 * Есть возможность передать функцию-коллбэк, которая будет
 * вызвана сразу после вызова setState с новым значением стейта
 * в качестве аргумента.
 *
 * ```ts
 * const onCountChange = React.useCallback((count) => {
 *   // обработчик нового значения count
 *   // будет вызван через 500мс
 * }, []);
 *
 *
 * const [count, setCount] = useStateWithDelay(initialState, 0, onCountChange);
 *
 * const click = () => {
 *   setCount(count + 1, 500)
 * }
 * ```
 */
export declare function useStateWithDelay<S>(initialState: S | (() => S), defaultDelay?: number, onStateChange?: (v: S) => void): [S, DispatchWithDelay<React.SetStateAction<S>>];
export {};
//# sourceMappingURL=useStateWithDelay.d.ts.map