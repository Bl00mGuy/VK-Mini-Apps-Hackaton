{"version":3,"sources":["../../../../src/components/Touch/Touch.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useStableCallback } from '../../hooks/useStableCallback';\nimport { getWindow, isHTMLElement } from '../../lib/dom';\nimport { coordX, coordY, touchEnabled, type VKUITouchEvent } from '../../lib/touch';\nimport type { HasComponent, HasRootRef } from '../../types';\n\nexport interface CustomTouchEvent extends Gesture {\n  originalEvent: VKUITouchEvent;\n}\n\nexport type HoverHandler = (outputEvent: MouseEvent) => void;\n\nexport type CustomTouchEventHandler = (event: CustomTouchEvent) => void;\n\nexport interface TouchProps\n  extends React.AllHTMLAttributes<HTMLElement>,\n    HasRootRef<HTMLElement>,\n    HasComponent {\n  /**\n   * Привязать onEnter и onLeave через pointer-events - работает на disabled-инпутах\n   */\n  usePointerHover?: boolean;\n  useCapture?: boolean;\n  slideThreshold?: number;\n  noSlideClick?: boolean;\n  onEnter?: HoverHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onLeave?: HoverHandler;\n  onStart?: CustomTouchEventHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onStartX?: CustomTouchEventHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onStartY?: CustomTouchEventHandler; // TODO [>=7] Заменить типы события в VKUITouchEvent на события из React\n  onMove?: CustomTouchEventHandler;\n  onMoveX?: CustomTouchEventHandler;\n  onMoveY?: CustomTouchEventHandler;\n  onEnd?: CustomTouchEventHandler;\n  onEndX?: CustomTouchEventHandler;\n  onEndY?: CustomTouchEventHandler;\n  stopPropagation?: boolean;\n}\n\nexport interface Gesture {\n  startX: number;\n  startY: number;\n  startT: Date;\n  duration: number;\n  isPressed: boolean;\n  isY: boolean;\n  isX: boolean;\n  isSlideX: boolean;\n  isSlideY: boolean;\n  isSlide: boolean;\n  clientX: number;\n  clientY: number;\n  shiftX: number;\n  shiftY: number;\n  shiftXAbs: number;\n  shiftYAbs: number;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Touch\n */\nexport const Touch = ({\n  onStart,\n  onStartX,\n  onStartY,\n  onMove,\n  onMoveX,\n  onMoveY,\n  onEnter,\n  onLeave,\n  onEnd,\n  onEndX,\n  onEndY,\n  onClickCapture,\n  usePointerHover,\n  slideThreshold = 5,\n  useCapture = false,\n  Component = 'div',\n  getRootRef,\n  noSlideClick = false,\n  stopPropagation = false,\n  ...restProps\n}: TouchProps) => {\n  const [isTouchEnabled] = React.useState(touchEnabled);\n  const gestureRef = React.useRef<Gesture | null>(null);\n  const didSlide = React.useRef(false);\n  const disposeTargetNativeGestureEvents = React.useRef<VoidFunction | null>(null);\n\n  const cleanupTargetNativeGestureEvents = () => {\n    gestureRef.current = null;\n    if (disposeTargetNativeGestureEvents.current) {\n      disposeTargetNativeGestureEvents.current();\n      disposeTargetNativeGestureEvents.current = null;\n    }\n  };\n\n  React.useEffect(() => cleanupTargetNativeGestureEvents, []);\n\n  /**\n   * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onEnd`/`onEndX`/`onEndY`.\n   */\n  const handleNativePointerUp = useStableCallback((event: MouseEvent | TouchEvent) => {\n    const gesture = gestureRef.current;\n\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n\n    if (gesture.isPressed) {\n      dispatchUserHandlers(event, gesture, [onEnd, onEndX, onEndY], stopPropagation);\n    }\n\n    if (isTouchEnabled) {\n      // https://github.com/VKCOM/VKUI/issues/4414\n      // если тач-устройство и был зафиксирован touchmove,\n      // то событие клика не вызывается\n      if (gesture.isSlide) {\n        didSlide.current = false;\n      }\n      // Если это был тач-евент, симулируем отмену hover\n      if (onLeave) {\n        onLeave(event as MouseEvent);\n      }\n    } else {\n      didSlide.current = Boolean(gesture.isSlide);\n    }\n\n    cleanupTargetNativeGestureEvents();\n  });\n\n  /**\n   * Note: используем `useStableCallback()`, чтобы не терялась область видимости `onMove`/`onMoveX`/`onMoveY`.\n   */\n  const handleNativePointerMove = useStableCallback((event: MouseEvent | TouchEvent) => {\n    const gesture = gestureRef.current;\n\n    /* istanbul ignore if: нужно для Typescript */\n    if (!gesture) {\n      return;\n    }\n\n    const clientX = coordX(event);\n    const clientY = coordY(event);\n\n    // смещения\n    const shiftX = clientX - gesture.startX;\n    const shiftY = clientY - gesture.startY;\n\n    // абсолютные значения смещений\n    const shiftXAbs = Math.abs(shiftX);\n    const shiftYAbs = Math.abs(shiftY);\n\n    // Если определяем мультитач, то прерываем жест\n    if ('touches' in event && event.touches.length > 1) {\n      return handleNativePointerUp(event);\n    }\n\n    // если мы ещё не определились\n    if (!gesture.isX && !gesture.isY) {\n      const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;\n      const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;\n      const willBeSlidedX = willBeX && (!!onMoveX || !!onMove);\n      const willBeSlidedY = willBeY && (!!onMoveY || !!onMove);\n\n      gesture.isY = willBeY;\n      gesture.isX = willBeX;\n      gesture.isSlideX = willBeSlidedX;\n      gesture.isSlideY = willBeSlidedY;\n      gesture.isSlide = willBeSlidedX || willBeSlidedY;\n    }\n\n    if (gesture.isSlide) {\n      gesture.clientX = clientX;\n      gesture.clientY = clientY;\n      gesture.shiftX = shiftX;\n      gesture.shiftY = shiftY;\n      gesture.shiftXAbs = shiftXAbs;\n      gesture.shiftYAbs = shiftYAbs;\n\n      dispatchUserHandlers(event, gesture, [onMove, onMoveX, onMoveY], stopPropagation);\n    }\n  });\n\n  const handlePointerDown = (\n    event: React.MouseEvent<HTMLElement> | React.TouchEvent<HTMLElement>,\n  ) => {\n    const nativeEvent = event.nativeEvent;\n\n    gestureRef.current = initGesture(coordX(nativeEvent), coordY(nativeEvent));\n\n    const shouldCallDirectionHandlerOnlyIsSlide = false;\n    dispatchUserHandlers(\n      event,\n      gestureRef.current,\n      [onStart, onStartX, onStartY],\n      stopPropagation,\n      shouldCallDirectionHandlerOnlyIsSlide,\n    );\n\n    const eventOptions = { capture: useCapture, passive: false };\n\n    // FIXME: заменить touch/mouse-события ниже на pointer-события после того, как бразуеры из\n    // .browserslistrc начнут поддерживать его (см. https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events#browser_compatibility).\n    if (isTouchEnabled) {\n      if (isHTMLElement(event.target)) {\n        // Тач-события не всплывают, поэтому навешиваем события на целевой элемент\n        // см. #235, #1968, https://stackoverflow.com/a/45760014\n        const target = event.target;\n\n        target.addEventListener('touchmove', handleNativePointerMove, eventOptions);\n        target.addEventListener('touchend', handleNativePointerUp, eventOptions);\n        target.addEventListener('touchcancel', handleNativePointerUp, eventOptions);\n\n        disposeTargetNativeGestureEvents.current = () => {\n          target.removeEventListener('touchmove', handleNativePointerMove, eventOptions);\n          target.removeEventListener('touchend', handleNativePointerUp, eventOptions);\n          target.removeEventListener('touchcancel', handleNativePointerUp, eventOptions);\n        };\n      }\n    } else {\n      // Используем события на Document, т.к. mouse-события на целевом элементе могут теряться при\n      // выходе за границы этого элемента.\n      const doc = getWindow(event.currentTarget).document;\n\n      doc.addEventListener('mousemove', handleNativePointerMove, eventOptions);\n      doc.addEventListener('mouseup', handleNativePointerUp, eventOptions);\n      doc.addEventListener('mouseleave', handleNativePointerUp, eventOptions);\n\n      disposeTargetNativeGestureEvents.current = () => {\n        doc.removeEventListener('mousemove', handleNativePointerMove, eventOptions);\n        doc.removeEventListener('mouseup', handleNativePointerUp, eventOptions);\n        doc.removeEventListener('mouseleave', handleNativePointerUp, eventOptions);\n      };\n    }\n  };\n\n  const handlePointerEnter = onEnter\n    ? (event: React.MouseEvent<HTMLElement>) => onEnter(event.nativeEvent)\n    : undefined;\n\n  const handlePointerLeave = onLeave\n    ? (event: React.MouseEvent<HTMLElement>) => onLeave(event.nativeEvent)\n    : undefined;\n\n  /**\n   * Отменяет нативное браузерное поведение для вложенных ссылок и изображений\n   */\n  const handleDragStart = (event: React.DragEvent<HTMLElement>) => {\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'A' || target.tagName === 'IMG') {\n      event.preventDefault();\n    }\n  };\n\n  /**\n   * Отменяет переход по вложенной ссылке, если был зафиксирован свайп\n   */\n  const handleClickCapture: typeof onClickCapture = (event) => {\n    if (!didSlide.current) {\n      return onClickCapture && onClickCapture(event);\n    }\n\n    if (noSlideClick) {\n      event.stopPropagation();\n\n      // https://github.com/VKCOM/VKUI/issues/1977\n      // https://github.com/VKCOM/VKUI/issues/3892\n      event.preventDefault();\n    } else {\n      onClickCapture && onClickCapture(event);\n    }\n\n    didSlide.current = false;\n  };\n\n  return (\n    <Component\n      {...restProps}\n      ref={getRootRef}\n      onDragStart={handleDragStart}\n      onClickCapture={handleClickCapture}\n      // onEnter\n      onPointerEnter={usePointerHover ? handlePointerEnter : undefined}\n      onMouseEnter={!usePointerHover ? handlePointerEnter : undefined}\n      // onLeave\n      onPointerLeave={usePointerHover ? handlePointerLeave : undefined}\n      onMouseLeave={!usePointerHover ? handlePointerLeave : undefined}\n      // handlePointerDown\n      onTouchStartCapture={isTouchEnabled && useCapture ? handlePointerDown : undefined}\n      onTouchStart={isTouchEnabled && !useCapture ? handlePointerDown : undefined}\n      onMouseDownCapture={!isTouchEnabled && useCapture ? handlePointerDown : undefined}\n      onMouseDown={!isTouchEnabled && !useCapture ? handlePointerDown : undefined}\n    />\n  );\n};\n\nfunction initGesture(startX: number, startY: number): Gesture {\n  return {\n    startX,\n    startY,\n    startT: new Date(),\n    duration: 0,\n    isPressed: true,\n    isY: false,\n    isX: false,\n    isSlideX: false,\n    isSlideY: false,\n    isSlide: false,\n    clientX: 0,\n    clientY: 0,\n    shiftX: 0,\n    shiftY: 0,\n    shiftXAbs: 0,\n    shiftYAbs: 0,\n  };\n}\n\ntype Handlers = [\n  CustomTouchEventHandler | undefined,\n  CustomTouchEventHandler | undefined,\n  CustomTouchEventHandler | undefined,\n];\n\nfunction dispatchUserHandlers(\n  event: MouseEvent | TouchEvent | React.MouseEvent | React.TouchEvent,\n  gesture: Gesture,\n  [handler, handlerX, handlerY]: Handlers,\n  stopPropagation?: boolean,\n  shouldCallDirectionHandlerOnlyIsSlide = true,\n) {\n  if (stopPropagation) {\n    event.stopPropagation();\n  }\n\n  const data = {\n    ...gesture,\n    originalEvent: event as unknown as VKUITouchEvent,\n    duration: Date.now() - gesture.startT.getTime(),\n  };\n\n  if (handler) {\n    handler(data);\n  }\n\n  if (handlerX) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideX) {\n        handlerX(data);\n      }\n    } else {\n      handlerX(data);\n    }\n  }\n\n  if (handlerY) {\n    if (shouldCallDirectionHandlerOnlyIsSlide) {\n      if (gesture.isSlideY) {\n        handlerY(data);\n      }\n    } else {\n      handlerY(data);\n    }\n  }\n}\n"],"names":["React","useStableCallback","getWindow","isHTMLElement","coordX","coordY","touchEnabled","Touch","onStart","onStartX","onStartY","onMove","onMoveX","onMoveY","onEnter","onLeave","onEnd","onEndX","onEndY","onClickCapture","usePointerHover","slideThreshold","useCapture","Component","getRootRef","noSlideClick","stopPropagation","restProps","isTouchEnabled","useState","gestureRef","useRef","didSlide","disposeTargetNativeGestureEvents","cleanupTargetNativeGestureEvents","current","useEffect","handleNativePointerUp","event","gesture","isPressed","dispatchUserHandlers","isSlide","Boolean","handleNativePointerMove","clientX","clientY","shiftX","startX","shiftY","startY","shiftXAbs","Math","abs","shiftYAbs","touches","length","isX","isY","willBeX","willBeY","willBeSlidedX","willBeSlidedY","isSlideX","isSlideY","handlePointerDown","nativeEvent","initGesture","shouldCallDirectionHandlerOnlyIsSlide","eventOptions","capture","passive","target","addEventListener","removeEventListener","doc","currentTarget","document","handlePointerEnter","undefined","handlePointerLeave","handleDragStart","tagName","preventDefault","handleClickCapture","ref","onDragStart","onPointerEnter","onMouseEnter","onPointerLeave","onMouseLeave","onTouchStartCapture","onTouchStart","onMouseDownCapture","onMouseDown","startT","Date","duration","handler","handlerX","handlerY","data","originalEvent","now","getTime"],"mappings":"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"}